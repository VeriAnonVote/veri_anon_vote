use crate::prelude::*;
use crate::wallet::Wallet;



#[derive(Builder, Serialize, Deserialize)]
pub struct SecretKeyGenerator {
    #[builder(default = "String::new()")]
    #[builder(setter(into))]
    wallet_adderss: String,

    /// message
    #[builder(default = "\"This is a default message for testing Ethereum signature functionality. It has no financial or operational implications.\".to_string()")]
    #[builder(setter(into))]
    msg: String,

    /// Optional field to store the signature.
    /// Wrapped in `Option` to handle the case where no signature has been generated yet.
    #[serde(skip_serializing)]
    #[builder(default = "None")]
    signature: Option<Vec<u8>>,

    /// store seed which generated by the signature.
    #[serde(skip_serializing)]
    #[builder(default = "[0u8; 32]")]
    seed: [u8; 32],
}



impl SecretKeyGenerator {
    pub async fn sign(mut self, wallet: &Wallet) -> AResult<Self> {
        let signature = wallet.signer
            .sign_message(self.msg.as_bytes())
            .await?;

        self.wallet_adderss = wallet.signer
            .address()
            .to_string();

        self.signature = Some(signature.into());

        Ok(self)
    }



    /// Get the signature field of Self (of type `Vec<u8>`). If this field has not been set through
    /// signing a message (i.e., its value is None), throw an error.
    ///
    /// Obtain the signature of a specific message with a specific private key. There are no
    /// specific requirements for format or algorithm; it only needs to ensure that an attacker
    /// cannot obtain it based on length and randomness.
    /// Theoretically, as long as it can return a password with very high random entropy, that would suffice.
    ///
    /// # Returns
    /// A Result containing the signature as a vector of bytes or an error if signing fails.
    pub fn signature(&self) -> AResult<Vec<u8>> {
        let signature = self.signature
            .clone()
            .ok_or(aerr!("have not signed"))?;


        Ok(signature)
    }


    /// Retrieves the seed array, generating a new one if it is currently all zeros.
    ///
    /// This function checks if the current seed is an array of all zeros. If it is,
    /// it generates a new seed by calling `generate_seed_from_signature`. If the seed
    /// is already non-zero, it returns a reference to the existing seed.
    ///
    /// # Errors
    ///
    /// This function returns an error if generating a new seed via
    /// `generate_seed_from_signature` fails.
    pub fn get_generated_seed(&mut self) -> AResult<[u8; 32]> {
        if self.seed == [0u8; 32] {
            self.generate_seed_from_signature()?;
        }

        Ok(self.seed)
    }

    /// Generates seed from the signature.
    ///
    /// This method hashes the signature to produce a secure seed for key generation.
    ///
    /// # Returns
    /// A Result with () or an error if generation fails.
    pub fn generate_seed_from_signature(&mut self) -> AResult<()> {
        // Get the signature from the implementing type
        let signature = self.signature()?;

        // Hash the signature to create a seed
        let mut hasher = Sha3_256::new();
        hasher.update(&signature);

        // Convert hash to a fixed size seed for keypair generation
        self.seed = hasher.finalize().into();

        Ok(())
    }


    #[cfg(feature = "scalar")]
    /// Generates Scalar from the seed which is generated by signature.
    ///
    /// # Returns
    /// A Result with Scalar or an error if generation fails.
    pub fn generate_scalar(&mut self) -> AResult<Scalar> {
        let seed = self.get_generated_seed()?;

        let secret_key = Scalar::from_bytes_mod_order(seed);

        Ok(secret_key)
    }
}




// // Implementing the `SignatureToKeyGenerator` trait for `SecretKeyGenerator`
// impl SignatureToKeyGenerator for SecretKeyGenerator {
//     /// Retrieve the stored signature or return an error if not available
//     fn signature(&self) -> anyhow::Result<Vec<u8>> {
//         let signature = self.signature
//             .clone()
//             .ok_or(anyhow::anyhow!("have not signed"))?;
//         Ok(signature)
//     }

//     fn message_info_json(&self) -> String {
//         serde_json::json!({
//             "message": self.msg,
//             "bip32_path": self.bip32_path,
//         }).to_string()
//     }

//     /// Generate a new instance by signing a message with a Trezor device using a BIP32 path
//     fn sign_with_bip32_path(path: &str, hint_message: &str) -> anyhow::Result<Self> {
//         let mut trezor_generator = SecretKeyGeneratorBuilder::default()
//             .bip32_path(path)
//             .build()
//             .unwrap();
//         let signature = trezor_generator.sign_msg_with_trezor(hint_message)?
//             .as_bytes().to_vec();
//         trezor_generator.signature = Some(signature);
//         trezor_generator.msg = hint_message.to_string();

//         Ok(trezor_generator)
//     }
// }

// // Additional methods for `SecretKeyGenerator`
// impl SecretKeyGenerator {
//     /// Sign a message using a connected Trezor device
//     pub fn sign_msg_with_trezor(&mut self, msg: &str) -> anyhow::Result<String> {
//         // Connect to a unique Trezor device
//         let mut connected_device = trezor_client::unique(false)?;
//         connected_device.initialize(None)?;

//         // Sign the message with Ethereum-specific signing method
//         let signature = connected_device.ethereum_sign_message(
//             msg.as_bytes().to_vec(),
//             bip32_path_to_vec(&self.bip32_path)?,
//         )?;

//         self.msg = msg.to_string();
//         Ok(signature_to_hex_string(&signature))
//     }
// }

// /// Convert a BIP32 path string to a vector of u32 for use in hardware wallet operations
// pub fn bip32_path_to_vec(s: &str) -> anyhow::Result<Vec<u32>> {
//     s.split('/')
//         .skip(1)
//         .map(|part| {
//             let is_hardened = part.ends_with('h') || part.ends_with('\'');
//             let num_str = if is_hardened {
//                 &part[..part.len() - 1]
//             } else {
//                 part
//             };

//             let num = num_str.parse::<u32>()?;

//             Ok(if is_hardened { num | 0x80000000 } else { num })
//         })
//         .collect()
// }

// /// Convert a signature to a hexadecimal string format
// pub fn signature_to_hex_string(signature: &Signature) -> String {
//     let mut hex_string = String::new();

//     // Convert 'r' component of the signature to hexadecimal
//     for &byte in &signature.r {
//         write!(hex_string, "{:02x}", byte).unwrap();
//     }

//     // Convert 's' component of the signature to hexadecimal
//     for &byte in &signature.s {
//         write!(hex_string, "{:02x}", byte).unwrap();
//     }

//     // Add the 'v' byte to the hexadecimal string
//     write!(hex_string, "{:02x}", signature.v).unwrap();

//     // Format the result with a '0x' prefix for Ethereum compatibility
//     format!("0x{}", hex_string)
// }

